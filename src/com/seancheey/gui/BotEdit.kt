package com.seancheey.gui

import com.seancheey.game.*
import javafx.fxml.FXML
import javafx.fxml.Initializable
import javafx.scene.Node
import javafx.scene.control.TextField
import javafx.scene.image.ImageView
import javafx.scene.input.*
import javafx.scene.layout.AnchorPane
import javafx.scene.layout.HBox
import javafx.scene.layout.StackPane
import javafx.scene.layout.TilePane
import java.net.URL
import java.util.*

/**
 * Created by Seancheey on 20/05/2017.
 * GitHub: https://github.com/Seancheey
 */

/** DataFormat of componentModel, used as a reference to componentModel in dragging clipboard **/
object modelFormat : DataFormat("object/componentModel")

/** generated by javafx, should be a singleton **/
private var editController: BotEdit? = null

/** for quick reference to game settings **/
private val gridWidth: Double = Config.botGridWidth

/** for quick reference to game settings **/
private val gridNum: Int = Config.botGridNum


/**
 * This BotEdit is used as a JavaFX controller
 * One should not create any new instance of this class
 */
class BotEdit : Initializable {
    /**
     * Component panes for player to select component models
     */
    @FXML
    var blocksPane: TilePane? = null
    @FXML
    var weaponsPane: TilePane? = null
    /**
     * Pane for player to edit their ships
     */
    @FXML
    var editPane: AnchorPane? = null
    /**
     * TextField of robot name
     */
    @FXML
    var nameField: TextField? = null
    /**
     * Robot selection HBox
     */
    @FXML
    var botGroupBox: HBox? = null

    /**
     * Index of player's selected index of bot group and model
     */
    var selectBotGroupIndex: Int = 0
    var selectBotModelIndex: Int = 0
    val editingRobot: RobotModel
        get() = Config.player.robots[selectBotGroupIndex][selectBotModelIndex]

    init {
        // make editController a singleton
        if (editController == null)
            editController = this
    }

    override fun initialize(location: URL?, resources: ResourceBundle?) {
        initModelFlowPanes()
        initEditPane()
        initBotGroup()
    }

    private fun initModelFlowPanes() {
        for (component in Models.BLOCKS) {
            blocksPane!!.children.add(ComponentModelSlot(component))
        }
    }

    private fun initEditPane() {
        val size = gridNum * gridWidth
        editPane!!.minWidth = size
        editPane!!.maxWidth = size
        // add grid to edit pane
        val grids = arrayListOf<ComponentGrid>()
        for (y in 0 until gridNum) {
            for (x in 0 until gridNum) {
                val grid = ComponentGrid(x, y)
                AnchorPane.setTopAnchor(grid, gridWidth * y)
                AnchorPane.setLeftAnchor(grid, gridWidth * x)
                grids.add(grid)
            }
        }
        editPane!!.children.addAll(grids)
        nameField!!.setMaxSize(size, size)
    }

    private fun initBotGroup() {
        // select player's first BotGroup to initialize
        val models = Config.player.robots[0]
        for ((i, model) in models.withIndex()) {
            val robotModelSlot = RobotModelSlot(model)
            robotModelSlot.setOnMouseClicked { setEditingRobot(i) }
            botGroupBox!!.children.add(robotModelSlot)
        }
    }

    fun setEditingRobot(index: Int) {
        selectBotModelIndex = index
        // change nameField
        editController!!.nameField!!.text = editingRobot.name
        // change components on grid
        editController!!.clearComponents()
        for ((model, x, y) in editingRobot.components) {
            editController!!.putComponent(model, x, y)
        }
    }

    fun saveRobot() {
        Config.player.robots[selectBotGroupIndex][selectBotModelIndex] = getRobotModel()
        botGroupBox!!.children.clear()
        initBotGroup()
    }

    fun clearComponents() {
        val toDelete = arrayListOf<ComponentView>()
        for (node in editPane!!.children) {
            if (node is ComponentView) {
                toDelete.add(node)
            }
        }
        for (view in toDelete) {
            editPane!!.children.remove(view)
        }
    }

    fun getRobotModel(): RobotModel {
        return RobotModel(nameField!!.text, getComponents())
    }

    private fun getComponents(): List<Component<ComponentModel>> {
        val components = arrayListOf<Component<ComponentModel>>()
        for (node in editPane!!.children) {
            if (node is ComponentView)
                components.add(node.toComponent())
        }
        return components
    }

    fun putComponent(componentModel: ComponentModel, x: Int, y: Int): Unit {
        putComponentView(componentModel, x, y)
        setGridsInRangeIsEnabled(x, y, componentModel.width, componentModel.height, false)
    }

    fun setGridsInRangeIsEnabled(x: Int, y: Int, width: Int, height: Int, value: Boolean) {
        for (y2 in y until y + height) {
            for (x2 in x until x + width) {
                val compGrid = getComponentGridAt(x2, y2)
                if (compGrid != null) {
                    compGrid.enabled = value
                }
            }
        }
    }

    private fun putComponentView(componentModel: ComponentModel, x: Int, y: Int) {
        val componentView = ComponentView(componentModel, x, y)
        AnchorPane.setLeftAnchor(componentView, x * gridWidth)
        AnchorPane.setTopAnchor(componentView, y * gridWidth)
        editPane!!.children.add(componentView)
    }

    private fun getComponentGridAt(x: Int, y: Int): ComponentGrid? {
        if (x < gridWidth || y < gridWidth) {
            for (node in editPane!!.children) {
                if (node is ComponentGrid) {
                    if (node.x == x && node.y == y) {
                        return node
                    }
                }
            }
        }
        return null
    }
}

/**
 * A component of a robot
 * It is created when a player drags component componentModel from a ComponentModelSlot to any grid
 */
class ComponentView(val componentModel: ComponentModel, val x: Int, val y: Int) : ImageView(componentModel.image) {
    init {
        setOnDragDetected { event ->
            dragComponentStart(componentModel, this, event)
            editController!!.editPane!!.children.remove(this)
            editController!!.setGridsInRangeIsEnabled(x, y, componentModel.width, componentModel.height, true)
        }
    }

    fun toComponent(): Component<ComponentModel> {
        return Component(componentModel, x, y, null)
    }
}

/**
 * A grid on editPane waiting to be filled by a component
 * It is created when BotEdit pane is initialized
 */
class ComponentGrid(val x: Int, val y: Int, componentModel: ComponentModel? = null) : StackPane() {

    var componentModel: ComponentModel? = null
    var enabled = true

    init {
        this.componentModel = componentModel

        minWidth = gridWidth
        minHeight = gridWidth
        maxWidth = gridWidth
        maxHeight = gridWidth

        setOnDragOver {
            event ->
            if (enabled) {
                event.acceptTransferModes(TransferMode.MOVE, TransferMode.LINK, TransferMode.COPY)
                event.consume()
            }
        }
        setOnDragDropped { event ->
            if (enabled) dragComponentEnd(x, y, event)
        }
    }
}

/**
 * A componentModel slot as an option to add to robot
 * It is created when BotEdit pane is initialized
 * ComponentModel slots are initialized according to data files
 */
class ComponentModelSlot(val componentModel: ComponentModel) : ImageView(componentModel.image) {

    init {
        // bind mouse location to hoverView
        setOnDragDetected { event ->
            dragComponentStart(componentModel, this, event)
        }
    }
}

fun dragComponentStart(componentModel: ComponentModel, node: Node, event: MouseEvent): Unit {
    // start drag with any transfer mode
    val db = node.startDragAndDrop(TransferMode.COPY, TransferMode.LINK, TransferMode.MOVE)
    // put the componentModel into clipboard
    val clipboard = ClipboardContent()
    clipboard.put(modelFormat, componentModel)
    db.setContent(clipboard)
    // set mouse holding image and offsets
    db.dragView = componentModel.image
    db.dragViewOffsetX = (componentModel.width - 1) * componentModel.image.width / componentModel.width / 2
    db.dragViewOffsetY = -(componentModel.height - 1) * componentModel.image.height / componentModel.height / 2

    event.consume()
}

fun dragComponentEnd(x: Int, y: Int, event: DragEvent) {
    if (event.dragboard.hasContent(modelFormat)) {
        val model = event.dragboard.getContent(modelFormat) as ComponentModel

        editController!!.putComponent(model, x, y)

        event.isDropCompleted = true
        event.consume()
    }
}
